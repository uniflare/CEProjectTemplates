# CMakePluginWithModule Example

This repository contains an example CryEngine plugin that uses the engine module system to dynamically load (or not) dlls. The ModuleExample project shows how to configure cmakelists.txt to create a separate project inside the same source code folder using add_subdirectory() keepign everythign contained in your base project folder.

##### Requirements
 - **CryEngine 5.3+** (Tested on 5.3.3)
 - **CMake 3.6.0** or higher
 - I will assume you are running a **64bit windows system**.
 - I will assume you are using **Visual Studio 2015 Update3** _or Newer_.
___
##### Project Structure
The example consists of 3 projects _**generated by CMake**_.

| Project               | Component             | Responsibility                                    |
| --------------------- | --------------------- | ------------------------------------------------- |
| CMakePluginWithModule | Plugin/System         | Handles the loading of each module/implementation |
| ExampleModule         | Implementation/Module | Essentially a "sub-plugin" but as IEngineModule   |
| ModuleCommon          | Common Interfaces     | Non-Build target. Holds public/common interfaces  |
 ___
##### QUICK TEST STEPS
**1** Create a new blank project. _This will serve as your host game plugin (Can use launcher to create project for CE5.3)._

**2** Build your blank project. _Make sure it works! (**Generate solution->Build Solution->Launch Game** via cryproject file)._

**3** Generate solution via cryproject file. _This will automatically build your project too (RelWithDebInfo)._

**4** Copy `CMakePluginWithModule/bin/win_x64/CMakePluginWithModule.dll` _Module System Plugin_
_to_ `BlankProject/bin/win_x64/CMakePluginWithModule.dll`

**5** Copy `CMakePluginWithModule/bin/win_x64/ExampleModule.dll` _Implementation_
_to_ `CRYENGINE_5.3/bin/win_x64/ExampleModule.dll` (Can use custom engine too ofc)

**6** Modify `BlankProject/cryplugin.csv` by adding the line below; _Before or after the game plugin_
 		`C++;ModuleExamplePlugin;Plugin_ModuleExample;bin/win_x64/CMakePluginWithModule.dll;Assets`

**7** Start the blank project. _Launch Game via cryproject file_.

**8** Once loaded, check file `BlankProject/game.log` for the line below:
 		`Loaded ExampleModule Implementation. String: Test String from Example Module.`
 
**Steps '4' and '5' need to be repeated on each build/rebuild. You can automate this with CMake using a PostBuild event**
_
___
### CMake Structure 
The structure of the plugin project cmakelists pretty much follows the the component layout - "Plugin"/"Implementation"/"CommonInterface". 

`Code/CmakeLists.txt`
This is the top-level cmakelists file responsible for the entire project generation.
It is essentially a very slightly modified version of a default CMakeLists.txt genereated by the blank plugin template. Differences include;
 -- _Removed the `ProjectName` variable in favour of harcoding each project name. This prevents name clashing with multiple projects_
 -- _Added the Common and ExampleModule CMakeLists by using add_subdirectory( [path] )_
 -- _Modified the target_include_directories() to include the Common header files_
 
`Code/modules/ExampleModule/CmakeLists.txt`
This is a module/implementation. Essentially another dll plugin.  For this reason you will notice it is almost identical to a stock/default plugin template CMakeLists file. Differences include;
 -- _Removed the `ProjectName` variable in favour of harcoding each project name. This prevents name clashing with multiple projects_
 -- _Modified the target_include_directories() to include the Common header files_
 
`Code/Common/CmakeLists.txt`
This is is a bit different. Since we don't actually build this project, we have to trick CMake/VS a little. 
Also for the crycommon interfaces to be included (for VS intellisense for ex.) we need to use a vcxproj.user and .props file.
It is reccommended to take a look at this `CMakeLists.txt` source file directly as well as the `ModuleCommon.vcxproj.user.in` and `ModuleCommon.props` files. These files are documented inside.
_
___
### Things to know
Take note of the following information;

* **_IMPORTANT:_** Each module (implementation) output dll must reside inside the engine binary folder
* Top-Level Cmakelists is responsible for loading/adding any sub cmakelist files
* (VS Only) Includes a props file which allows the interface project to properly include crycommon headers
* (VS Only) Creates a separate VS Solution file for each sub project (Common/ExampleModule)
* As it is, using the `EngineModule` interfaces for the implementations is generally thought as **not** good, the usage is intended for internal engine use and as it does and can work (as demonstrated here) the modules require a callback to pass their instance pointer back to the system(plugin). Usually each engine module will have its own spot to fill inside the global `gEnv` struct. In this example, a custom global struct has been created that we can fill with "optional" implementations/modules.
* Implementations can be added relatively easily. The module system effectively mirrors the module framework of `CryAudioSystem` without the `ATL` obviously.

___
For more information or help feel free to pm me on the forums (uniflare) or poke me on slack.

Disclaimer: This is an educational resource and not meant to be used as-is for any serious project. Take what you need. Don't blame me if something comes up down the line. More examples to follow.